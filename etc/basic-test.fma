@!prae{
  @@ let x = 1 + 2;
  @@ let y = 3 + 4;
  @@ () => 1.0 + 2.0;

  @@ let myBool = true;
  @@ let myInt8 = 1sy;
  @@ let myInt16 = 1h;
  @@ let myInt32 = 1;
  @@ let myInt64 = 1l;
  @@ let myUint8 = 1y;
  @@ let myUint16 = 1uh;
  @@ let myUint32 = 1u;
  @@ let myUint64 = 1ul;
  @@ let myFloat = 1f;
  @@ let myDouble = 1d;
  @@ let myString = "hi";

  @@ var myString2 = "hey";

  @@ if (true) myString2 = "hi";
  @@ else myString2 = 0;

  @@ var myString2 = if (true) "hi" else 0;

  var myString2;

  if (let x = true; x)
    myString2 = "hi";
  else
    myString2 = @[ 0 @] "there";

  let f = () => "hi";
  let g = (a: a) => if (a) "hi" else "bye";

  let h = (a: a) => if (a) a else false;

  let i = () => { return 0; };

  @@ let f = () => "hi";
  let x = 1 + 2;
  let y = x + 2;
  @@ return y; @@ x * 3 / y; @@ TODO: Return statements should be invalid here
@}

@!prae{
  let cout = nil;

  let myFn = (a: a, b: b) => {
    return 5;
  };

  let compare = (min: Bool min) =>
    if (min) (a: a, b: b) => (if (a < b) a else b)
    else (a: a, b: b) => (if (a > b) a else b);

  let functional = () => 5;

  let functionalWhere = () => (let x = 5; x);
  let imperative = () => { let x = 5; return x; };

  var my = (let a = 5; a);
  var your = (var b = 5; b);

  {
    your += 5;
  };

  your = my = -1;

  while (var i = 0, j = 10; i + j < 100) ++i;

  while (var i = 0; i < 100) {
    cout[print: i[toString] + (if (i % 2 == 0) " is even" else " is odd")];
    ++i;
  };
@}