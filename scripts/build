#!/usr/bin/env ruby

require_relative "rninja/rninja"

RNinja.config(file: "build.yaml") do
  init :debug,
    :debug_symbols,
    :diagnostic,
    :optimize,
    :sanitize

  defaults afl: false,
    build_profile: false,
    dashOFast: false,
    diagnostic: false,
    gen: :ninja,
    no_lto: false

  profile :release, {
    debug: false,
    debug_symbols: false,
    diagnostic: false,
    sanitize: false,
    optimize: true,
  }

  profile :debug, {
    debug: true,
    debug_symbols: true,
    sanitize: true,
    optimize: false,
  }

  profile :afl, {
    debug: true,
    afl: true,
  }

  profile :diagnostic, {
    debug: true,
    diagnostic: true,
  }

  profile :make, {
    gen: :make,
  }
end

RNinja.run(rn_dir: "build/rninja", gen: RNinja[:gen]) do
  san_flags = (["address", "undefined"].map{|s| "-fsanitize=#{s}" } if config(:sanitize))

  set bin_d: "bin",
    build_d: "build",
    include_d: "include",
    script_d: "scripts",
    src_d: "src",
    tool_d: "tools",
    ast_d: "$build_d/ast",
    cp: "cp",
    ruby: "ruby",
    astgen: "$script_d/ast.rb",
    flex: "flex",
    bison: "$script_d/run-bison bison",
    re2c: "re2c",
    cc: config(:afl) ? "afl-clang" : "clang",
    cxx: config(:afl) ? "afl-clang++" : "clang++",
    ld: "$cxx"

  include_dirs = [
    "$include_d",
  ]

  includes = [
    *(include_dirs.flat_map{|i| ["-I#{i}", "-isystem #{i}"] }),
  ]

  cc_pch_files = [
  ].map{|p| [p, "#{p.sub("$include_d", "$build_d/include")}.pch"] }

  cxx_pch_files = [
  ].map{|p| [p, "#{p.sub("$include_d", "$build_d/include")}.pch"] }

  cc_pchs = cc_pch_files.map{|_, o| "-include-pch #{o}" }
  cxx_pchs = cxx_pch_files.map{|_, o| "-include-pch #{o}" }

  pkcflags = Set[]
  pkcxxflags = Set[]
  pkldflags = Set[]

  # Packages registered with pkg-config
  %w[].each do |pkg|
    cflags = Command.read("pkg-config --cflags '#{pkg}'").split(/\s+/)
    pkcflags.merge(cflags)
    pkcxxflags.merge(cflags)
    pkldflags.merge(Command.read("pkg-config --libs '#{pkg}'").split(/\s+/))
  end

  # General LLVM flags
  llvm_cppflags = Command.read("llvm-config --cppflags").split(/\s+/)
  pkcflags.merge(llvm_cppflags)
  pkcxxflags.merge(llvm_cppflags)
  pkldflags.merge(Command.read("llvm-config --ldflags").split(/\s+/))

  # LLVM components
  %w[all].each do |cmp|
    pkldflags.merge(Command.read("llvm-config --libs '#{cmp}'").split(/\s+/))
  end

  # Libraries to link against
  ldlibs = %w[dl].map{|s| "-l#{s}" }

  set astgen_flags: [
      "-f$src_d/scanner.in.lpp:$build_d/scanner.lpp",
      "-b$src_d/parser.in.ypp:$build_d/parser.ypp",
      "-t$src_d/ast/token.in.hpp:$build_d/ast/token.hpp",
      *("-v" if config(:debug)),
    ],
    flex_flags: [
      "--ecs",
      "--full",
    ],
    bison_flags: [
      "--warnings=all",
      "--report=all",
    ],
    re2c_flags: [
      "--empty-class error",
      "-W",
      "-Werror-undefined-control-flow",
    ],
    cc_flags: [
      "-fcolor-diagnostics",
      "-ferror-limit=0",
      "-std=c11",
      *("-g" if config(:debug_symbols)),
      *("-flto" if config(:optimize) && !config(:no_lto)),
      *(config(:debug) ? [
        *("-O0" unless config(:optimize)),
        "-DDEBUG",
        "-D_DEBUG",
      ] : [
        "-DNDEBUG",
        "-D_NDEBUG",
      ]),
      *(config(:diagnostic) ? [
        "-DDEBUG_DIAGNOSTIC",
        "-D_DEBUG_DIAGNOSTIC",
      ] : []),
      *(config(:build_profile) ? [
        "-v",
        "-ftime-report",
      ] : []),
      *pkcflags,
      *san_flags,
      *includes,
      *("-O#{config(:dashOFast) ? "fast" : 3}" if config(:optimize)),
    ],
    cxx_flags: [
      "-fcolor-diagnostics",
      "-ferror-limit=0",
      "-std=c++17",
      *(config(:diagnostic) ? [
        "-DDEBUG_DIAGNOSTIC",
        "-D_DEBUG_DIAGNOSTIC",
      ] : []),
      *("-g3" if config(:debug_symbols)),
      *("-flto" if config(:optimize) && !config(:no_lto)),
      *(config(:debug) ? [
        *("-O0" unless config(:optimize)),
        "-D_GLIBCXX_DEBUG",
        "-D_GLIBCXX_DEBUG_PEDANTIC",
        "-D_LIBCPP_DEBUG",
        "-DDEBUG",
        "-D_DEBUG",
      ] : [
        "-DNDEBUG",
        "-D_NDEBUG",
      ]),
      *(config(:build_profile) ? [
        "-v",
        "-ftime-report",
      ] : []),
      *pkcxxflags,
      *san_flags,
      *includes,
      *("-O#{config(:dashOFast) ? "fast" : 3}" if config(:optimize)),
    ],
    cc_diags: [
      "-Wall",
      "-Wextra",
      "-Wimplicit",
      "-Wshadow",
      "-Wunused",
    ],
    cxx_diags: [
      "-Wall",
      "-Wconversion",
      "-Wdeprecated",
      "-Wextra",
      "-Wimplicit",
      "-Winvalid-noreturn",
      "-Wmissing-noreturn",
      "-Wmissing-prototypes",
      "-Wmissing-variable-declarations",
      "-Wnewline-eof",
      "-Wshadow-all",
      "-Wno-logical-op-parentheses",
      "-Wno-shorten-64-to-32",
      "-Wno-sign-compare",
      "-Wno-sign-conversion",
      "-Wtautological-compare",
      "-Wthread-safety",
      "-Wunreachable-code-aggressive",
      "-Wunused",
      "-Werror=implicit-fallthrough",
      "-Werror=old-style-cast",
      "-Werror=return-type",
      "-Werror=switch",
      *(config(:diagnostic) ? [
        "-fdiagnostics-show-template-tree",
        "-Wswitch-bool",
        "-Wswitch-enum",
        "-Wweak-template-vtables",

        # Anti-spam measures:
        "-fno-caret-diagnostics",
        "-fno-diagnostics-fixit-info",
      ] : [
        # Disabled by diagnostic as anti-spam measure:
        "-fno-elide-type",
        "-ftemplate-backtrace-limit=0",
      ]),
    ],
    cc_pchs: cc_pchs,
    cxx_pchs: cxx_pchs,
    ld_flags: [
      *("-flto" if config(:optimize) && !config(:no_lto)),
      *ldlibs,
      *pkldflags,
      *san_flags,
    ]

  rule :cp,
    command: "$cp -R -- $in $out",
    description: "cp $in $out"

  rule :ruby,
    command: "$ruby $ruby_flags $flags $in $args"

  rule :flex,
    build: ".cpp",
    from: ".lpp",
    command: "$flex $flex_flags $flags -o $out $in"

  rule :bison,
    build: ".cpp",
    from: ".ypp",
    command: "$bison $bison_flags $flags -o $out $in"

  rule :re2c,
    build: ".cpp",
    from: ".re",
    command: "$re2c $re2c_flags $flags -o $out $in"

  rule :cc,
    build: ".o",
    from: ".c",
    command: "$cc $cc_flags $cc_diags $cc_pchs $flags -MMD -MF $out.d -c -o $out $in",
    deps: "gcc",
    depfile: "$out.d",
    restat: true

  rule :cxx,
    build: ".o",
    from: ".cpp",
    command: "$cxx $cxx_flags $cxx_diags $cxx_pchs $flags -MMD -MF $out.d -c -o $out $in",
    deps: "gcc",
    depfile: "$out.d",
    restat: true

  rule :cc_pch,
    build: ".pch",
    from: ".h",
    command: "$cc $cc_flags $flags -MMD -MF $out.d -c -o $out -xc++-header $in",
    deps: "gcc",
    depfile: "$out.d",
    restat: true

  rule :cxx_pch,
    build: ".pch",
    from: ".hpp",
    command: "$cxx $cxx_flags $flags -MMD -MF $out.d -c -o $out -xc++-header $in",
    deps: "gcc",
    depfile: "$out.d",
    restat: true

  rule :ld,
    build: "",
    from: ".o",
    info: "link $out",
    command: "$ld $ld_flags $flags -o $out $in"

  cc_pch_files.each do |file, out|
    build out, from: file, with: :cc_pch
  end

  cxx_pch_files.each do |file, out|
    build out, from: file, with: :cxx_pch
  end

  cc_pch_outs = cc_pch_files.map{|_, o| o }

  cxx_pch_outs = cxx_pch_files.map{|_, o| o }

  build "$build_d/scanner.cpp", from: "$build_d/scanner.lpp"
  build "$build_d/parser.cpp",
    also: var_paths(:build_d, "parser.hpp", "parser.output", "stack.hh"),
    from: "$build_d/parser.ypp"

  (astgen_from, astgen_imply) = %w[l i].map! do |flag|
    var_rel_paths(:ast_d, *Command.read(expand("ruby '$astgen' -#{flag} $astgen_flags '$ast_d'")).split(" "))
  end

  build astgen_from, also: astgen_imply, with: "ruby",
    from: "$astgen",
    imply: [
      *var_paths(:src_d, "parser.in.ypp", "scanner.in.lpp", "ast/token.in.hpp"),
      "$script_d/ast.rb",
      *var_glob(:script_d, "astgen/**/*.rb"),
    ],
    description: "astgen $astgen",
    args: "$astgen_flags $ast_d",
    restat: true

  objs = []

  set includes: ["$src_d", "$build_d"].map{|i| "-I#{i}" }

  folders = %i[
    algow
    ast
    diagnostic
    forma
    intermedia
    parser
    pipeline
    praeforma
    util
  ]

  [
    "$src_d/formab.cpp",
    *folders.flat_map{|f| var_glob(:src_d, "#{f}/**/*.cpp") },
  ].each do |file|
    obj = File.change_ext(file.sub("$src_d", "$build_d"), ".o")
    build obj, from: file,
      flags: "$includes"
    objs << obj
  end

  [
    *folders.flat_map{|f| var_glob(:src_d, "#{f}/**/*.re") },
  ].each do |file|
    rel = File.rel_path(file, "$src_d")
    src = var_path(:build_d, "#{rel}.cpp")
    obj = var_path(:build_d, "#{rel}.o")
    build src, from: file
    build obj, from: src,
      flags: ["$includes", *("-I#{File.dirname(file)}" unless File.dirname(rel).empty?)]
    objs << obj
  end

  build "$build_d/scanner.o", from: "$build_d/scanner.cpp",
    flags: "$includes"
  objs << "$build_d/scanner.o"

  build "$build_d/parser.o", from: "$build_d/parser.cpp",
    flags: ["$includes", "-Wno-deprecated", "-Wno-weak-vtables"]
  objs << "$build_d/parser.o"

  astgen_from.select{|f| f.end_with?(".cpp") }.each do |from|
    obj = File.change_ext(from, ".o")
    build obj, from: from,
      flags: ["$includes", "-Wno-switch-enum"]
    objs << obj
  end

  build "$bin_d/formab", from: objs

  phony "formab", is: "$bin_d/formab",
    description: "build formab",
    default: true
end
