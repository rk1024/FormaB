%define parse.error verbose
%defines
%language "c++"
%locations
%name-prefix "frma"

%define parse.trace

%param {frma::FormaParserTag *tag}

%code requires {
#include "ast.hpp"
#include "parserTag.hpp"
}

%code provides {
#define YYSTYPE frma::parser::semantic_type
#define YYSTRIM($$) if (!$$->rooted()) delete $$;
#undef yylex


int frmalex(YYSTYPE *, frma::location *, void *);

static inline int yylex(YYSTYPE *yylval, frma::location *yylloc, frma::FormaParserTag *tag) {
  return frmalex(yylval, yylloc, tag->scan);
}
}

%astgen-union

%union {
  frma::FormaToken *_tok;
}

%astgen-dtors

%destructor { if (!$$->rooted()) delete $$; } <_tok>

%token LParen   "("
%token RParen   ")"
%token LBracket "["
%token RBracket "]"
%token LBrace   "{"
%token RBrace   "}"

%token MKWFunction  "function"
%token MKWInterface "interface"
%token MKWLet       "let"
%token MKWOperator  "operator"
%token MKWRecord    "record"
%token MKWStruct    "struct"
%token MKWSyntax    "syntax"

%token MOPComma ","
%token MOPEqual "="
%token MOPSemi  ";"

%token MetaBlockStart
%token MetaBlockEnd

%token <_tok> RawBlockID
%token <_tok> RawBlockBody
%token <_tok> Operator
%token <_tok> Identifier
%token <_tok> PPDirective
%token <_tok> Number
%token <_tok> SQLiteral
%token <_tok> DQLiteral

%type <_primaries> Input
%type <_tok> MetaLetLHS
%astgen-types

%start Input

%initial-action {
  @$.begin.filename = @$.end.filename = &tag->filename();
}

%%
Input: PrimariesOpt { $$ = $1; tag->prims = $1; };

%astgen-syntax

MetaLetLHS: "let" Identifier[ident] "=" { $$ = $ident; };

CommaOpt:
  %empty |
  ",";
%%

void frma::parser::error(const frma::location &loc, const std::string &msg) {
  tag->error(loc, msg);
}
