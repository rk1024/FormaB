%define parse.error verbose
%defines
%language "c++"
%locations
%name-prefix "frma"

%define parse.trace

%param {frma::FormaParserTag *tag}

%code requires {
#include "ast.hpp"
#include "parserTag.hpp"
}

%code provides {
#define YYSTYPE frma::parser::semantic_type
#define YYSTRIM($$) if (!$$->rooted()) delete $$;
#undef yylex


int frmalex(YYSTYPE *, frma::location *, void *);

static int yylex(YYSTYPE *yylval, frma::location *yylloc, frma::FormaParserTag *tag) {
  return frmalex(yylval, yylloc, tag->scan);
}
}

%union {
  frma::FormaAST *    _ast;
  frma::FormaToken *  _tok;
  frma::FormaPrims *  _prims;
  frma::FormaPrim *   _prim;
  frma::FormaGroup *  _group;
  frma::FormaRawBlk * _rawblk;
  frma::FormaMetaBlk *_metablk;
}

%destructor { if (!($$->rooted() || tag->prims == $$)) delete $$; } <_prims>;
%destructor { YYSTRIM($$); } <_prim>;
%destructor { YYSTRIM($$); } <_group>;
%destructor { YYSTRIM($$); } <_rawblk>;
%destructor { YYSTRIM($$); } <_metablk>;

%token Comment

%token LParen   "("
%token RParen   ")"
%token LBracket "["
%token RBracket "]"
%token LBrace   "{"
%token RBrace   "}"

%token MKWFunction  "function"
%token MKWInterface "interface"
%token MKWLet       "let"
%token MKWOperator  "operator"
%token MKWRecord    "record"
%token MKWStruct    "struct"
%token MKWSyntax    "syntax"

%token MOPComma ","
%token MOPEqual "="
%token MOPSemi  ";"

%token MetaBlockStart
%token MetaBlockEnd

%token <_tok> RawBlockID
%token <_tok> RawBlockBody
%token <_tok> Operator
%token <_tok> Identifier
%token <_tok> PPDirective
%token <_tok> Number
%token <_tok> SQLiteral
%token <_tok> DQLiteral

%type <_group>   PGroup
%type <_group>   KGroup
%type <_group>   CGroup
%type <_rawblk>  RawBlock
%type <_metablk> MetaBlock
%type <_prims>   Input
%type <_prims>   PrimariesOpt
%type <_prims>   Primaries
%type <_prim>    Primary

%start Input

%initial-action {
  @$.begin.filename = @$.end.filename = &tag->filename();
}

%%
Input: PrimariesOpt { $$ = $1; tag->prims = $1; };

PrimariesOpt:
  %empty    { $$ = new FormaPrims(nullptr); } |
  Primaries { $$ = $1; };

Primaries:
  Primary                       { $$ = new FormaPrims($1); } |
  Primaries[init] Primary[prim] { $$ = new FormaPrims($init, $prim); };

Primary:
  PGroup      { $$ = new FormaPrim($1); } |
  KGroup      { $$ = new FormaPrim($1); } |
  CGroup      { $$ = new FormaPrim($1); } |
  RawBlock    { $$ = new FormaPrim($1); } |
  MetaBlock   { $$ = new FormaPrim($1); } |
  Identifier  { $$ = new FormaPrim(FormaPrim::Identifier, $1); } |
  PPDirective { $$ = new FormaPrim(FormaPrim::PPDirective, $1); } |
  Number      { $$ = new FormaPrim(FormaPrim::Number, $1); } |
  SQLiteral   { $$ = new FormaPrim(FormaPrim::SQLiteral, $1); } |
  DQLiteral   { $$ = new FormaPrim(FormaPrim::DQLiteral, $1); } |
  Operator    { $$ = new FormaPrim(FormaPrim::Operator, $1); };

RawBlock: RawBlockID[id] RawBlockBody[body] { $$ = new FormaRawBlk($id, $body); };

MetaBlock: MetaBlockStart MetaDeclarationsOpt MetaBlockEnd { $$ = new FormaMetaBlk(); };

PGroup: "(" PrimariesOpt[prims] ")" { $$ = new FormaGroup(FormaGroup::PGroup, $prims); };
KGroup: "[" PrimariesOpt[prims] "]" { $$ = new FormaGroup(FormaGroup::KGroup, $prims); };
CGroup: "{" PrimariesOpt[prims] "}" { $$ = new FormaGroup(FormaGroup::CGroup, $prims); };



MetaDeclarationsOpt:
  %empty |
  MetaDeclarations;

MetaDeclarations:
  MetaDeclaration |
  MetaDeclarations MetaDeclaration;

MetaDeclaration:
  MetaSyntaxExtension |
  MetaLetDeclaration;

MetaSyntaxExtension: "syntax" "(" Primaries[prims] ")" MetaLetLHS MetaFuncRecord { YYSTRIM($prims) };

MetaLetDeclaration: MetaLetLHS MetaLetRHS;

MetaLetLHS: "let" Identifier[ident] "=" { YYSTRIM($ident) };

MetaLetRHS:
  MetaFunction |
  MetaRecord;

MetaFuncRecord:
  MetaFunction |
  MetaRecord;

MetaFunction: "function" MetaFuncArgs MetaFuncBody;
MetaRecord: "record" MetaFuncArgs;

MetaFuncArgs: "(" MetaArguments CommaOpt ")";

CommaOpt:
  %empty |
  ",";

MetaArguments:
  MetaArgument |
  MetaArguments "," MetaArgument;

MetaArgument: Identifier[type] Identifier[name] { YYSTRIM($type); YYSTRIM($name); };

MetaFuncBody:
  MetaFuncExprBody |
  MetaFuncStmtBody;

MetaFuncExprBody: "=>" MetaExpression;

MetaFuncStmtBody: "{" MetaStatements "}";

MetaStatements:
  MetaStatement |
  MetaStatements MetaStatement;

MetaStatement:
  ";" |
  MetaLetStatement ";"
  MetaExpression ";";

MetaLetStatement: "let" Identifier[name] "=" MetaExpression { YYSTRIM($name) };

MetaExpression: %empty;
%%

void frma::parser::error(const frma::location &loc, const std::string &msg) {
  tag->error(loc, msg);
}
