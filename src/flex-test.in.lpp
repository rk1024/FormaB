/*%array*/

%option 8bit
%option batch never-interactive
%option stack
%option bison-bridge bison-locations
%option reentrant pointer
%option prefix="frma"

%option noyywrap

%option debug nodefault warn backup perf-report

%top{
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wold-style-cast"
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunused-function"
}

%{
#include <iostream>
#include <map>
#include <stdexcept>
#include <string>

#include "parserTag.hpp"
#include "lexerDriver.hpp"
#include "bison-test.hpp"

#define YYSTYPE frma::parser::semantic_type
#define YYLTYPE frma::location
#define YY_EXTRA_TYPE frma::FormaParserTag *
#define YY_DECL int frmalex(YYSTYPE *yylval_param, YYLTYPE *yylloc_param, yyscan_t yyscanner)

typedef frma::parser::token tk;

#define $x yyg->yyextra_r

#define $E(value) { $x->error(*yylloc, value); yyterminate(); }

#define $TK(value) return tk::value;

#define $SKT(text) yylval->_tok = new frma::FormaToken(text);

#define $SK $SKT(yytext)
#define $SKB $SKT($B)

#define $YKT(type, text) $SKT(text) $TK(type)
#define $YK(type) $SK $TK(type)
#define $YKB(type) $SKB $TK(type)
#define $YKE(type) $SKB $BE $TK(type)

#define $SSBEGIN(value) BEGIN(SS##value);
#define $SSPUSH(value) yy_push_state(SS##value, yyscanner);
#define $SSPOP yy_pop_state(yyscanner);

#define $END yyterminate();

#define $BS $x->bufStart();
#define $BE $x->bufEnd();
#define $BR $x->bufReturn();

#define $BW $x->buf() << yytext;

#define $BSW $BS $BW

#define $B $x->buf().str()

#define $SL yylloc->step();

#define $MN(n) { yylloc->columns(n); yylineno += n; }
#define $WN(n) yylloc->lines(n);

#define $ML $MN(yyleng)
#define $MO $MN(1)

#define $WL $WN(yyleng)
#define $WO $WN(1)
YY_DECL;
%}

%astgen-token-rules

Whitespace    [ \r\t]
Newline       [\v\n]
LCommentOpen  @@
LCommentClose \n
LCommentInput [^\n]

BCommentOpen  @\[
BCommentClose @+\]
BCommentNoAt  [^@\n]
BCommentAts   @+[^\]\n]?

RawBlockStart @!
RawBlockOpen  \{
RawBlockClose @+\}
RawBlockNoAt  [^@\n]
RawBlockAts   @+[^\}\n]?

MetaBlockID meta

SQuote \'
DQuote \"

SABQuote \`

IDStart    [a-zA-Z_]
PPStart    @
NumStart   [0-9]
OpStart    [`~!#$%^&*=+|;:,<.>/?-]
Identifier [0-9a-zA-Z_]
Number     [0-9a-zA-Z_.]
Operator   [`~!@#$%^&*_=+|;:,<.>/?-]
SQChar     [^'\\]
DQChar     [^"\\]
QLEscape   \\.

%x SSBComment

%x SSRawBlockStart
%x SSRawBlockID
%x SSMetaBlockID
%x SSRawBlock
%x SSMetaBlock
%x SSSyntaxExtArgs

%%
<INITIAL,SSMetaBlock,SSSyntaxExtArgs>{
  {Whitespace}+ { $SL $ML }
}

<INITIAL,SSMetaBlock,SSSyntaxExtArgs>{
  {LCommentOpen}{LCommentInput}*{LCommentClose} { $SL $WO }

  {BCommentOpen} { $SL $ML $SSPUSH(BComment) }
}

<SSBComment>{
  {BCommentClose}  { $SL $ML $SSPOP }
  {BCommentNoAt}+  { $SL $ML }
  {BCommentAts}+   { $SL $ML }

  <<EOF>> { $SL $ML $E("unterminated block comment") }
}

{RawBlockStart} { $SL $ML $SSPUSH(RawBlockStart) }

<SSRawBlockStart>{
  {MetaBlockID} { $SL $ML $SSBEGIN(MetaBlockID) }

  %astgen-token RawBlockID /{IDStart}{Identifier}*/ { $SL $ML $SSBEGIN(RawBlockID) } capture
}

<SSRawBlockID>{
  {RawBlockOpen} { $SL $ML $SSBEGIN(RawBlock) $BS }
}

<SSMetaBlockID>{
  /*{ignore me}*/
  %astgen-token MetaBlockStart /{RawBlockOpen}/ { $SL $ML $SSBEGIN(MetaBlock) }
}

<SSRawBlock>{
  {Newline}+ { $WL $BW }

  %astgen-token RawBlockBody /{RawBlockClose}/ { $ML $SSPOP } capture buf end

  {RawBlockNoAt}+ { $ML $BW }
  {RawBlockAts}+  { $ML $BW }
}

<SSMetaBlock>{
  /*{ignore me}*/
  %astgen-token MetaBlockEnd /{RawBlockClose}/ { $SL $ML $SSPOP }

  %astgen-token SAStart /{SABQuote}/ { $SL $ML $SSPUSH(SyntaxExtArgs) }

  %astgen-token MKWFunction "function" { $SL $ML }
  %astgen-token MKWInterface "interface" { $SL $ML }
  %astgen-token MKWLet "let" { $SL $ML }
  %astgen-token MKWRecord "record" { $SL $ML }
  %astgen-token MKWStruct "struct" { $SL $ML }

  %astgen-token MOPComma "," { $SL $ML }
  %astgen-token MOPDiv "/" { $SL $ML }
  %astgen-token MOPEqGT "=>" { $SL $ML }
  %astgen-token MOPEqual "=" { $SL $ML }
  %astgen-token MOPMinus "-" { $SL $ML }
  %astgen-token MOPMod "%" { $SL $ML }
  %astgen-token MOPMul "*" { $SL $ML }
  %astgen-token MOPPeriod "." { $SL $ML }
  %astgen-token MOPPlus "+" { $SL $ML }
  %astgen-token MOPSemi ";" { $SL $ML }
}

<SSRawBlock,SSMetaBlock>{
  <<EOF>> { $ML $BE $E("unterminated raw block") }
}

<SSSyntaxExtArgs>{
  /*{ignore me}*/
  %astgen-token SAEnd /{SABQuote}/ { $SL $ML $SSPOP }
  %astgen-token SAOPLLBrace "{{"
  %astgen-token SAOPRRBrace "}}"

  <<EOF>> { $ML $BE $E("unterminated syntax extension arguments") }
}

<INITIAL,SSMetaBlock,SSSyntaxExtArgs>{
  /*{ignore me}*/
  %astgen-token LParen "("
  %astgen-token RParen ")"
  %astgen-token LBracket "["
  %astgen-token RBracket "]"
  %astgen-token LBrace "{"
  %astgen-token RBrace "}"

  %astgen-token Identifier /{IDStart}{Identifier}*/ { $SL $ML } capture
  %astgen-token PPDirective /{PPStart}{Identifier}*/ { $SL $ML } capture
  %astgen-token Number /{NumStart}{Number}*/ { $SL $ML } capture

  %astgen-token SQLiteral /{SQuote}({SQChar}|{QLEscape})*{SQuote}{Identifier}*/ { $SL $ML } capture
  %astgen-token DQLiteral /{DQuote}({DQChar}|{QLEscape})*{DQuote}{Identifier}*/ { $SL $ML } capture
}

%astgen-token Operator /{OpStart}{Operator}*/ { $SL $ML } capture

<<EOF>> { $SL $ML $END }

<*>{
  {Newline}+ { $SL $WL }
  .          { $SL $ML $E(std::string("unexpected character '") + yytext + "'") }
}
%%

namespace frma {
  lexer::lexer(frma::FormaParserTag &tag) {
    if (int ret = frmalex_init_extra(&tag, &m_yyscanner))
      throw new std::runtime_error(std::string("Scanner creation failed with code ") + std::to_string(ret));

    tag.scan = m_yyscanner;
  }

  lexer::~lexer() {
    if (int ret = frmalex_destroy(m_yyscanner))
      throw new std::runtime_error(std::string("Scanner destructor failed with code ") + std::to_string(ret));
  }

  bool lexer::debug() const { return frmaget_debug(m_yyscanner); }

  void lexer::debug(bool value) { frmaset_debug(value, m_yyscanner); }

  FILE *lexer::inFile() const { return frmaget_in(m_yyscanner); }

  void lexer::inFile(FILE *value) { frmaset_in(value, m_yyscanner); }

  FILE *lexer::outFile() const { return frmaget_out(m_yyscanner); }

  void lexer::outFile(FILE *value) { frmaset_out(value, m_yyscanner); }
}

#pragma clang diagnostic pop