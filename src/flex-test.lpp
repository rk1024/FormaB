/*%array*/

%option 8bit
%option batch never-interactive
%option stack
%option bison-bridge bison-locations
%option reentrant pointer
%option prefix="frma"

%option noyywrap

%option yylineno

%option nodefault warn

%top{
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wold-style-cast"
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunused-function"
}

%{
#include <iostream>
#include <map>
#include <stdexcept>
#include <string>

#include "parserTag.hpp"
#include "lexerDriver.hpp"
#include "bison-test.hpp"

#define YYSTYPE frma::parser::semantic_type
#define YYLTYPE frma::location
#define YY_EXTRA_TYPE frma::FormaParserTag *
#define YY_DECL int frmalex(YYSTYPE *yylval_param, YYLTYPE *yylloc_param, yyscan_t yyscanner)

typedef frma::parser::token tk;

#define $x yyg->yyextra_r

#define $E(value) { $x->error(*yylloc, value); yyterminate(); }

#define $TK(value) return tk::value;

#define $YK(var, type, value) { yylval->var = new frma::Forma##type(yytext); $TK(value) }

#define $SL yylloc->step();

#define $MN(n) yylloc->columns(n);
#define $WN(n) yylloc->lines(n);

#define $ML $MN(yyleng)
#define $MO $MN(1)

#define $WL $WN(yyleng)
#define $WO $WN(1)
YY_DECL;
%}

Whitespace    [ \r\t]
Newline       [\v\n]
LCommentOpen  @@
LCommentClose \n
LCommentInput [^\n]

BCommentOpen  @\[
BCommentClose @+\]
BCommentNoAt  [^@\n]
BCommentAts   @+[^\]\n]?

RawBlockStart @
RawBlockOpen  \{
RawBlockClose @+\}
RawBlockNoAt  [^@\n]
RawBlockAts   @+[^\}\n]?

Backslash   \\

LParen      \(
RParen      \)
LBracket    \[
RBracket    \]
LBrace      \{
RBrace      \}
SQuote      \'
DQuote      \"

IDStart    [a-zA-Z_]
PPStart    @
NumStart   [0-9]
OpStart    [`~!#$%^&*=+|;:,<.>/?-]
Identifier [0-9a-zA-Z_]
Number     [0-9a-zA-Z_.]
Operator   [`~!@#$%^&*_=+|;:,<.>/?-]
SQChar     [^'\\]
DQChar     [^"\\]
QLEscape   \\.

%x BComment
%x RawBlock

%%
{Whitespace}+ { $SL $ML }
{Newline}+    { $SL $WL }

{LCommentOpen}{LCommentInput}*{LCommentClose} { $SL $WO } // Line comment, noop

{BCommentOpen} { $SL $ML yy_push_state(BComment, yyscanner); }

<BComment>{
  {Newline}+ { $SL $WL }

  {BCommentClose}  { $SL $ML yy_pop_state(yyscanner); }
  {BCommentNoAt}+  { $SL $ML }
  {BCommentAts}+   { $SL $ML }

  <<EOF>> { $SL $ML $E("unterminated block comment") }
}

{RawBlockStart}{IDStart}{Identifier}*{RawBlockOpen} { $SL $ML yy_push_state(RawBlock, yyscanner); }

<RawBlock>{
  {Newline}+ { $SL $WL }

  {RawBlockClose} { $SL $ML yy_pop_state(yyscanner); }
  {RawBlockNoAt}+ { $SL $ML }
  {RawBlockAts}+  { $SL $ML }

  <<EOF>> { $SL $ML $E("unterminated raw block") }
}

{LParen} { $SL $ML $TK(LParen) }
{RParen} { $SL $ML $TK(RParen) }

{LBracket} { $SL $ML $TK(LBracket) }
{RBracket} { $SL $ML $TK(RBracket) }

{LBrace} { $SL $ML $TK(LBrace) }
{RBrace} { $SL $ML $TK(RBrace) }

{IDStart}{Identifier}* { $SL $ML $YK(_ident, Ident, Identifier) }
{PPStart}{Identifier}+ { $SL $ML $YK(_pp, PP, PPDirective) }
{NumStart}{Number}*    { $SL $ML $YK(_literal, Literal, Number) }
{OpStart}{Operator}*   { $SL $ML $YK(_oper, Oper, Operator) }

{SQuote}({SQChar}|{QLEscape})*{SQuote}{Identifier}* { $SL $ML $YK(_literal, Literal, SQLiteral); }
{DQuote}({DQChar}|{QLEscape})*{DQuote}{Identifier}* { $SL $ML $YK(_literal, Literal, DQLiteral); }

. { $SL $ML $E("unexpected character"); }

<<EOF>> { $SL $ML yyterminate(); }
%%

namespace frma {
  lexer::lexer(frma::FormaParserTag &tag) {
    if (int ret = frmalex_init_extra(&tag, &m_yyscanner))
      throw new std::runtime_error(std::string("Scanner creation failed with code ") + std::to_string(ret));

    tag.scan = m_yyscanner;
  }

  lexer::~lexer() {
    if (int ret = frmalex_destroy(m_yyscanner))
      throw new std::runtime_error(std::string("Scanner destructor failed with code ") + std::to_string(ret));
  }

  bool lexer::debug() const { return frmaget_debug(m_yyscanner); }

  void lexer::debug(bool value) { frmaset_debug(value, m_yyscanner); }

  FILE *lexer::inFile() const { return frmaget_in(m_yyscanner); }

  void lexer::inFile(FILE *value) { frmaset_in(value, m_yyscanner); }

  FILE *lexer::outFile() const { return frmaget_out(m_yyscanner); }

  void lexer::outFile(FILE *value) { frmaset_out(value, m_yyscanner); }
}

#pragma clang diagnostic pop