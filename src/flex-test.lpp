/*%array*/

%option 8bit
%option batch never-interactive
%option stack
%option bison-bridge bison-locations
%option reentrant pointer
%option prefix="frma"

%option noyywrap

%option yylineno

%option nodefault warn

%top{
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wold-style-cast"
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunused-function"
}

%{
#include <iostream>
#include <map>
#include <string>

#include "parserTag.hpp"
#include "lexerDriver.hpp"
#include "bison-test.hpp"

#define YYSTYPE frma::parser::semantic_type
#define YYLTYPE frma::location
#define YY_EXTRA_TYPE frma::FormaParserTag *
#define YY_DECL int frmalex(YYSTYPE *yylval_param, YYLTYPE *yylloc_param, yyscan_t yyscanner)

typedef frma::parser::token tk;

#define $x yyg->yyextra_r

#define $E(value) { $x->error(*yylloc, value); yyterminate(); }

#define $TK(value) return tk::value;

#define $YK(var, type, value) { yylval->var = new frma::Forma##type(yytext); $TK(value) }

#define $SL yylloc->step();

#define $MN(n) yylloc->columns(n);
#define $WN(n) yylloc->lines(n);

#define $ML $MN(yyleng)
#define $MO $MN(1)

#define $WL $WN(yyleng)
#define $WO $WN(1)
YY_DECL;
%}

Whitespace    [ \r\t]
Newline       [\v\n]
LCommentOpen  @@
BCommentOpen  @\[
LCommentClose \n
BCommentClose @+\]
LCommentInput [^\n]
BCommentNoAt  [^@\n]
BCommentAts   @+[^\]\n]?

Backslash   \\

LParen      \(
RParen      \)
LBracket    \[
RBracket    \]
LBrace      \{
RBrace      \}
SQuote      \'
DQuote      \"

IDStart    [a-zA-Z_]
PPStart    @
NumStart   [0-9]
OpStart    [`~!#$%^&*=+|;:,<.>/?-]
Identifier [0-9a-zA-Z_]
Number     [0-9a-zA-Z_.]
Operator   [`~!@#$%^&*_=+|;:,<.>/?-]
SQChar     [^'\\]
DQChar     [^"\\]
QLEscape   \\.

%x BComment

%%
{Whitespace}+ { $SL $ML }
{Newline}+    { $SL $WL }

{LCommentOpen}{LCommentInput}*{LCommentClose} { $SL $WO } // Line comment, noop

{BCommentOpen} { $SL $ML yy_push_state(BComment, yyscanner); }

<BComment>{
  {Newline}+    { $SL $WL }

  {BCommentClose}  { $SL $ML yy_pop_state(yyscanner); }
  {BCommentNoAt}+  { $SL $ML }
  {BCommentAts}+   { $SL $ML }

  <<EOF>> { $SL $ML $E("unterminated block comment") }
}

{LParen} { $SL $ML $TK(LParen) }
{RParen} { $SL $ML $TK(RParen) }

{LBracket} { $SL $ML $TK(LBracket) }
{RBracket} { $SL $ML $TK(RBracket) }

{LBrace} { $SL $ML $TK(LBrace) }
{RBrace} { $SL $ML $TK(RBrace) }

{IDStart}{Identifier}* { $SL $ML $YK(_ident, Ident, Identifier) }
{PPStart}{Identifier}+ { $SL $ML $YK(_pp, PP, PPDirective) }
{NumStart}{Number}*    { $SL $ML $YK(_literal, Literal, Number) }
{OpStart}{Operator}*   { $SL $ML $YK(_oper, Oper, Operator) }

{SQuote}({SQChar}|{QLEscape})*{SQuote}{Identifier}* { $SL $ML $YK(_literal, Literal, SQLiteral); }
{DQuote}({DQChar}|{QLEscape})*{DQuote}{Identifier}* { $SL $ML $YK(_literal, Literal, DQLiteral); }

. { $SL $ML $E("unexpected character"); }

<<EOF>> { $SL $ML yyterminate(); }
%%

// int main() {
//   yyscan_t scan = {0};
//   FTLexerTag tag;
//   int err = 0;

//   if ((err = frmalex_init_extra(&tag, &scan))) goto catch1;

//   while (true) {
//     tk tok = frmalex(scan);

//     if (tag.error) {
//       std::cerr << "Lexical error occurred!" << std::endl;
//       err = 1;
//       goto catch1;
//     }

//     std::string str(frmaget_text(scan), frmaget_leng(scan));

//     std::cout << "[tk] " << tkNames[tok] << " '" << str << "'" << std::endl;

//     if (tok == tk::Eof) break;
//   }

//   goto finally1;

// catch1:
//   std::cerr << "Something bad happened." << std::endl;

// finally1:
//   {
//     int err2 = 0;

//     if ((err2 = frmalex_destroy(scan)))
//       std::cerr << "Something *REALLY* bad happened." << std::endl;

//     err = err || err2;
//   }

//   return err;
// }

namespace frma {
  int lex_init_extra(YY_EXTRA_TYPE extra, yyscan_t *scan) {
    if (int ret = frmalex_init_extra(extra, scan)) return ret;

    frmaset_debug(true, *scan);

    return 0;
  }

  int lex_destroy(yyscan_t scan) {
    return frmalex_destroy(scan);
  }
}

#pragma clang diagnostic pop