/*************************************************************************
 *
 * FormaB - the bootstrap Forma compiler (scanner.in.lpp)
 * Copyright (C) 2017-2018 Ryan Schroeder, Colin Unger
 *
 * FormaB is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 *
 * FormaB is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with FormaB.  If not, see <https://www.gnu.org/licenses/>.
 *
 ************************************************************************/

%option nodefault warn backup perf-report
%option 8bit
%option batch never-interactive
%option stack
%option bison-bridge bison-locations
%option reentrant pointer
%option prefix="frma"

%option noyywrap

/* TODO: Only do this in debug builds */
%option debug

%top{
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wimplicit-fallthrough"
#pragma clang diagnostic ignored "-Wold-style-cast"
#pragma clang diagnostic ignored "-Wunreachable-code"
#pragma clang diagnostic ignored "-Wunused-function"
}

%{
#include "parser/parserTag.hpp"
#include "parser/lexerDriver.hpp"
#include "parser.hpp"

#define YYSTYPE fps::parser::semantic_type
#define YYLTYPE fdi::FLocation
#define YY_EXTRA_TYPE fps::FParserTag *
#define YY_DECL int frmalex(YYSTYPE *yylval_param,                             \
                            YYLTYPE *yylloc_param,                             \
                            yyscan_t yyscanner)

using tk = fps::parser::token;

#define $x yyg->yyextra_r

#define $E(value) $x->error(*yylloc, std::string("lexical error: ") + value);

#define $F(value) do { \
  $E(value); \
  yyterminate(); \
} while (false);

#define $SSBEGIN(value) BEGIN(SS##value);
#define $SSPUSH(value) yy_push_state(SS##value, yyscanner);
#define $SSPOP yy_pop_state(yyscanner);

#define $END yyterminate();

#define $BS $x->bufStart();
#define $BE $x->bufEnd();
#define $BR $x->bufReturn();

#define $BW $x->buf() << yytext;

#define $BSW $BS $BW

#define $SL yylloc->step();

#define $MN(n) yylloc->columns(n);

#define $WN(n) do { \
  yylloc->lines(n); \
  yylineno += n; \
} while (false);

#define $ML $MN(yyleng)
#define $MO $MN(1)

#define $WL $WN(yyleng)
#define $WO $WN(1)

#define $SM $SL $ML

#define $LN(n) yyless(n);

YY_DECL;
%}

%astgen-token-defs

Whitespace [ \r\t]
Newline [\v\n]

LCommentOpen @@
ShebangCommentOpen #!
LCommentClose [\v\n]
LCommentInput [^\v\n]

BCommentOpen @\[
BCommentClose @+\]
BCommentNoAt [^@\v\n]
BCommentAts @+[^\]\v\n]?

PIdentStart [a-zA-Z]
PIdentPart  [a-zA-Z0-9_]

PNumDecStart \.
PNumStart [0-9]
PNumPart  [a-zA-Z0-9_.]

%x SSStart
%x SSBComment
%x SSPraeforma

%%
<SSStart>{
  {ShebangCommentOpen}{LCommentInput}*{LCommentClose} { $SL $WO $SSPOP $BS }
  . { $SSPOP $LN(0) $BS }
}

<INITIAL,SSPraeforma>{
  {LCommentOpen}{LCommentInput}*{LCommentClose} { $SL $WO }

  {BCommentOpen} { $SM $SSPUSH(BComment) }

  <<EOF>> { $END }
}

<SSBComment>{
  {BCommentClose} { $SM $SSPOP }
  {BCommentNoAt}+ { $SM }
  {BCommentAts}+ { $SM }

  <<EOF>> { $SM $F("unterminated block comment") }
}

%astgen-token Fragment /([^@\n\v]|@[^!@\[\n\v])+/ { $SM } capture
%astgen-token NewlineFragment /{Newline}+/ { $SL $WL } capture

%astgen-token PraeStart "@!prae{" { $SM $SSPUSH(Praeforma) }

<SSPraeforma>{
  %astgen-token PraeEnd "@}" { $SM $SSPOP }

  {Whitespace}+ { $SM }

  /* Keywords */
  %astgen-token PKWElse  "else"  { $SM }
  %astgen-token PKWFalse "false" { $SM }
  %astgen-token PKWIf    "if"    { $SM }
  %astgen-token PKWLet   "let"   { $SM }
  %astgen-token PKWTrue  "true"  { $SM }

  %astgen-token PIdent  /{PIdentStart}{PIdentPart}*|[_@]{PIdentPart}+/ { $SM } capture
  %astgen-token PNumber /{PNumDecStart}?{PNumStart}{PNumPart}*/ { $SM } capture

  /* Grouping */
  %astgen-token PLParen "(" { $SM }
  %astgen-token PRParen ")" { $SM }
  %astgen-token PLBrack "[" { $SM }
  %astgen-token PRBrack "]" { $SM }
  %astgen-token PLBrace "{" { $SM }
  %astgen-token PRBrace "}" { $SM }

  /* General Symbols */
  %astgen-token PAnon  "_"  { $SM }
  %astgen-token PGives "=>" { $SM }
  %astgen-token PSemi  ";"  { $SM }

  /* Operators */
  %astgen-token PAdd "+"  { $SM }
  %astgen-token PAsg "="  { $SM }
  %astgen-token PDiv "/"  { $SM }
  %astgen-token PEql "==" { $SM }
  %astgen-token PGeq ">=" { $SM }
  %astgen-token PGrt ">"  { $SM }
  %astgen-token PLeq "<=" { $SM }
  %astgen-token PLss "<"  { $SM }
  %astgen-token PMod "%"  { $SM }
  %astgen-token PMul "*"  { $SM }
  %astgen-token PSub "-"  { $SM }
}

<*>{
  {Newline}+ { $SL $WL }

  . { $SM $E(std::string("unexpected character '") + yytext + "'") }
}
%%

namespace fps {
  FLexer::FLexer(fps::FParserTag &tag)
      : m_logger(&tag.logger()) {
    if (int ret = frmalex_init_extra(&tag, &m_yyscanner))
      throw std::runtime_error(std::string("scanner constructor failed, code ")
                               + std::to_string(ret));

    tag.scan = m_yyscanner;
  }

  FLexer::~FLexer() {
    if (int ret = frmalex_destroy(m_yyscanner))
      m_logger->error("lexer", "scanner destructor failed, code "
                               + std::to_string(ret));
  }

  void FLexer::init() {
    yy_push_state(SSStart, m_yyscanner);
  }

#if defined(_DEBUG)
  bool FLexer::debug() const { return frmaget_debug(m_yyscanner); }

  void FLexer::debug(bool value) { frmaset_debug(value, m_yyscanner); }
#endif

  FILE *FLexer::inFile() const { return frmaget_in(m_yyscanner); }

  void FLexer::inFile(FILE *value) { frmaset_in(value, m_yyscanner); }

  FILE *FLexer::outFile() const { return frmaget_out(m_yyscanner); }

  void FLexer::outFile(FILE *value) { frmaset_out(value, m_yyscanner); }
}

#pragma clang diagnostic pop